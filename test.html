<!DOCTYPE html>
<html>

<head>
    <title>RSA Encryption</title>
</head>

<body>
    <h1>RSA Encryption</h1>
    <button onclick="generateKeys()">Generate Keys</button>
    <br>
    <label for="publicKey">Public Key (n, e):</label>
    <textarea id="publicKey" rows="3" cols="60" readonly></textarea>
    <br>
    <label for="privateKey">Private Key (n, d):</label>
    <textarea id="privateKey" rows="3" cols="60" readonly></textarea>
    <br>
    <label for="inputData">Input Data:</label>
    <textarea id="inputData" rows="10" cols="60"></textarea>
    <br>
    <button onclick="encryptData()">Encrypt Data</button>
    <button onclick="decryptData()">Decrypt Data</button>
    <br>
    <label for="encryptedData">Encrypted Data:</label>
    <textarea id="encryptedData" rows="10" cols="60" readonly></textarea>
    <br>
    <label for="decryptedData">Decrypted Data:</label>
    <textarea id="decryptedData" rows="10" cols="60" readonly></textarea>

    <script>
        // Hàm tạo cặp khóa RSA
        function gcd(a, b) {
            // Tính ước chung lớn nhất (GCD) của hai số a và b
            while (b !== 0) {
                const temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function modInverse(a, m) {
            // Tìm nghịch đảo modulo của a trong mod m
            let m0 = m;
            let x0 = 0;
            let x1 = 1;

            if (m === 1) {
                return 1;
            }

            while (a > 1) {
                const q = Math.floor(a / m);
                let t = m;

                m = a % m;
                a = t;
                t = x0;
                x0 = x1 - q * x0;
                x1 = t;
            }

            if (x1 < 0) {
                x1 += m0;
            }

            return x1;
        }

        const PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697];

        function preprocessor(number) {
            for (const i of PRIMES) {
                if (number === i) {
                    return true;
                }
                else if (number % i === 0) {
                    return false;
                }
            }
            return true;
        }

        // Hàm tính lũy thừa modulo
        function powerMod(base, exponent, modulus) {
            if (modulus === 1) return 0;
            let result = 1;
            base = base % modulus;
            while (exponent > 0) {
                if (exponent % 2 === 1) {
                    result = (result * base) % modulus;
                }
                exponent = Math.floor(exponent / 2);
                base = (base * base) % modulus;
            }
            return result;
        }

        // Hàm kiểm tra số nguyên tố bằng thuật toán Fermat
        function isPrimeFermat(p, iterations) {
            if (p <= 1) return false;
            if (p <= 3) return true;
            for (let i = 0; i < iterations; i++) {
                const a = Math.floor(Math.random() * (p - 3)) + 2; // Chọn a ngẫu nhiên từ 2 đến p-2
                if (powerMod(a, p - 1, p) !== 1) {
                    return false; // p không phải là số nguyên tố
                }
            }
            return true; // p có thể là số nguyên tố
        }

        function millerRabin(p, iterations) {
            if (p <= 1) return false;
            if (p <= 3) return true;
            if (p % 2 === 0) return false; // Số chẵn không thể là số nguyên tố

            // Phân tích p - 1 thành dạng (2^r) * d
            let r = 0;
            let d = p - 1;
            while (d % 2 === 0) {
                r++;
                d /= 2;
            }

            // Thực hiện kiểm tra với các witness
            for (let i = 0; i < iterations; i++) {
                const a = Math.floor(Math.random() * (p - 3)) + 2; // Chọn a ngẫu nhiên từ 2 đến p-2
                let x = powerMod(a, d, p);
                if (x === 1 || x === p - 1) {
                    continue;
                }
                for (let j = 0; j < r - 1; j++) {
                    x = powerMod(x, 2, p);
                    if (x === p - 1) {
                        break;
                    }
                }
                if (x !== p - 1) {
                    return false; // p không phải là số nguyên tố
                }
            }
            return true; // p có thể là số nguyên tố

        }

        // Hàm tìm số nguyên tố kế tiếp lớn hơn number
        function nextPrime(number) {
            if (number % 2 == 0) {
                number += 1;
            }
            while (!isPrime(number)) {
                console.log(number)
                number += 2;
            }
            return number;
        }

        // Hàm sinh số nguyên tố ngẫu nhiên có độ dài bits
        function getPrime(bits) {
            let number = generateRandomNumber(bits);
            number = nextPrime(number);
            return number;
        }

        function isPrime(number) {
            return preprocessor(number) && isPrimeFermat(number, 20) && millerRabin(number, 20);
        }

        function rsaKeyPair(size) {
            const p = getPrime(size)
            const q = getPrime(size)

            const euler = (p - 1) * (q - 1);
            const carmichael = euler / gcd(p - 1, q - 1);

            const n = p * q;
            let e = 65537;
            while (gcd(e, carmichael) !== 1) {
                e = Math.floor(Math.random() * (carmichael - 2)) + 2;
            }

            const d = modInverse(e, euler);
            return {
                n,
                e,
                d
            }
        }

        let publicKey, privateKey;

        // Hàm tạo cặp khóa RSA
        function generateRSAKeyPair(keySize) {
            const {
                n,
                e,
                d
            } = rsaKeyPair(keySize);
            publicKey = {
                n: n,
                e: e
            };
            privateKey = {
                n: n,
                d: d
            };
        }

        // Hàm xử lý khi người dùng nhấn nút Generate Keys
        function generateKeys() {
            const keySize = 1024;
            generateRSAKeyPair(keySize);
            document.getElementById('publicKey').value = "n: " + publicKey.n + "\ne:" + publicKey.e;
            document.getElementById('privateKey').value = "n: " + privateKey.n + "\nd:" + privateKey.d;
        }

        // Hàm mã hóa RSA
        function rsaEncrypt(data, publicKey) {
            const e = publicKey.e,
                n = publicKey.n;
            const encryptedData = data.split('').map(char => BigInt(char.charCodeAt(0)) ** BigInt(e) % BigInt(n));
            return encryptedData;
        }

        // Hàm mã hóa dữ liệu sử dụng khóa công khai RSA
        function encryptRSA(publicKey, data) {
            const encryptedData = rsaEncrypt(data, publicKey);
            return encryptedData;
        }

        // Hàm xử lý khi người dùng nhấn nút Encrypt Data
        function encryptData() {
            const inputData = document.getElementById('inputData').value;
            const encryptedData = encryptRSA(publicKey, inputData);
            document.getElementById('encryptedData').value = encryptedData.join('\n');
        }


        // Hàm sinh số ngẫu nhiên có độ dài n bits
        function generateRandomNumber(bitLength) {
            if (bitLength <= 0) {
                throw new Error('bitLength must be a positive integer');
            }

            let randomBits = '';
            for (let i = 0; i < bitLength; i++) {
                // Sinh ngẫu nhiên bit 0 hoặc 1
                const randomBit = Math.random() < 0.5 ? '0' : '1';
                randomBits += randomBit;
            }
            return BigInt(`0b${randomBits}`);
        }

        // Hàm giải mã RSA
        function rsaDecrypt(encryptedData, key) {
            const d = key.d;
            const n = key.n;
            const result = [];
            const temp = encryptedData.split("\n")
            for (const char of temp) {
                const decryptedChar = String.fromCharCode(BigInt(char) ** BigInt(d) % BigInt(n));
                result.push(decryptedChar);
            }
            return result.join('');
        }

        // Hàm xử lý khi người dùng nhấn nút Decrypt Data
        function decryptData() {
            const encryptedData = document.getElementById('inputData').value;
            const decryptedData = rsaDecrypt(encryptedData, privateKey);

            document.getElementById('decryptedData').value = decryptedData;
        }

        // Hàm chuyển đổi ArrayBuffer sang dạng số nguyên dương hệ thập phân
        function arrayBufferToDecimal(arrayBuffer) {
            let decimal = 0;
            const bytes = new Uint8Array(arrayBuffer);
            for (let i = 0; i < bytes.length; i++) {
                decimal = decimal * 256 + bytes[i];
            }
            return decimal;
        }

        // Hàm chuyển đổi dạng số nguyên dương hệ thập phân sang ArrayBuffer
        function decimalToArrayBuffer(decimal) {
            const bytes = [];
            while (decimal > 0) {
                bytes.unshift(decimal % 256);
                decimal = Math.floor(decimal / 256);
            }
            return new Uint8Array(bytes);
        }
    </script>
</body>

</html>